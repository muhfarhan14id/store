<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Monkey Type Writer Live</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&family=JetBrains+Mono:wght@500;700&display=swap');

        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: manipulation; /* Improves touch response */
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Hide Scrollbar but keep functionality */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Animations */
        @keyframes pulse-yellow {
            0%, 100% { box-shadow: 0 0 0 0px rgba(226, 183, 20, 0.4); }
            50% { box-shadow: 0 0 0 4px rgba(226, 183, 20, 0); }
        }

        .active-word-container {
            background-color: #3d3b38;
            border-left: 4px solid #e2b714;
            padding-left: 8px;
        }

        /* Character Feedback Styles */
        .char-correct { color: #84cc16; } /* Lime-500 */
        .char-wrong { color: #ef4444; text-decoration: underline; } /* Red-500 */
        .char-default { color: #6b7280; } /* Gray-500 */
        .active-word-text { color: #e2b714; font-weight: bold; } /* Yellow base for active word */
    </style>
</head>
<body class="bg-[#2c2b29] text-[#e2b714] fixed inset-0 w-full h-full overflow-hidden flex flex-col">

    <!-- Background Decoration -->
    <div class="absolute inset-0 opacity-5 pointer-events-none bg-[radial-gradient(circle_at_top,_var(--tw-gradient-stops))] from-yellow-500 via-transparent to-transparent"></div>

    <!-- MAIN LAYOUT: Split into Top (Game) and Bottom (Keyboard Space) -->
    
    <!-- TOP SECTION: Game UI (Always Visible) -->
    <div class="w-full max-w-2xl mx-auto p-4 flex flex-col shrink-0 z-10" id="gameArea">
        
        <!-- Header -->
        <header class="flex justify-between items-center mb-2 bg-[#3d3b38] p-2 rounded-lg border-b-2 border-[#e2b714]/20">
            <div class="flex items-center gap-2">
                <i data-lucide="timer" class="w-5 h-5 text-red-400"></i>
                <span id="timer" class="text-xl font-bold text-red-400 font-mono">15s</span>
            </div>
            <div class="flex items-center gap-4">
                 <div class="text-center">
                     <span class="text-[10px] uppercase text-gray-400 block">Skor</span>
                     <span id="score" class="text-lg font-bold text-white leading-none">0</span>
                 </div>
                 <div class="text-center border-l border-gray-600 pl-4">
                    <span class="text-[10px] uppercase text-gray-400 block">High Score</span>
                    <span id="highScore" class="text-lg font-bold text-[#e2b714] leading-none">0</span>
               </div>
            </div>
        </header>

        <!-- Words Display Area -->
        <!-- Fixed height small enough to fit above keyboard -->
        <div class="relative bg-[#1e1d1b] rounded-t-xl border-x border-t border-[#e2b714]/10 overflow-hidden">
            
            <!-- Loading Overlay -->
            <div id="loader" class="absolute inset-0 flex items-center justify-center bg-[#1e1d1b] z-20">
                <div class="flex items-center gap-2">
                    <i data-lucide="loader-2" class="w-5 h-5 animate-spin text-[#e2b714]"></i>
                    <span class="text-sm text-gray-400">Memuat kata...</span>
                </div>
            </div>

            <!-- Scrollable Words Container -->
            <!-- Height restricted to ~140px (approx 3 lines) to ensure visibility -->
            <div id="wordsContainer" class="h-[140px] overflow-hidden p-4 text-2xl font-mono leading-relaxed flex flex-wrap content-start gap-x-3 gap-y-3 relative">
                <!-- Words injected here -->
            </div>
            
            <!-- Fade overlay at bottom of text area -->
            <div class="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-[#1e1d1b] to-transparent pointer-events-none"></div>
        </div>

        <!-- Input Area (Attached to bottom of words area) -->
        <div class="w-full relative bg-[#3d3b38] p-2 rounded-b-xl shadow-lg border border-[#e2b714]/20">
            <div class="absolute -top-3 right-4 bg-[#e2b714] text-[#2c2b29] text-[10px] px-2 py-0.5 rounded-full font-bold hidden" id="bonusTimeAnim">+5s</div>
            
            <input type="text" id="wordInput" 
                class="w-full bg-[#2c2b29] text-white border border-gray-600 focus:border-[#e2b714] rounded-lg px-3 py-3 text-lg font-mono outline-none transition-colors"
                placeholder="Ketik..." 
                autocomplete="off" 
                autocorrect="off" 
                autocapitalize="off" 
                spellcheck="false"
                enterkeyhint="go"
                disabled
            >
            <div class="flex justify-between items-center px-1 mt-1">
                <p class="text-[10px] text-gray-500">Spasi / Enter untuk lanjut</p>
                <div id="liveStatus" class="w-2 h-2 rounded-full bg-red-500"></div>
            </div>
        </div>
    </div>

    <!-- BOTTOM SECTION: Empty Spacer for Keyboard -->
    <div class="flex-1 bg-transparent" id="keyboardSpacer">
        <!-- This area will be covered by keyboard on mobile -->
    </div>

    <!-- OVERLAYS -->
    
    <!-- Start / Game Over -->
    <div id="overlay" class="fixed inset-0 bg-[#2c2b29]/95 z-50 flex items-center justify-center backdrop-blur-sm p-4">
        <div class="text-center w-full max-w-sm">
            <div class="flex justify-center mb-4">
                <div class="w-20 h-20 bg-[#e2b714] rounded-full flex items-center justify-center shadow-[0_0_20px_rgba(226,183,20,0.3)]">
                    <span class="text-4xl">üêµ</span>
                </div>
            </div>
            <h1 class="text-3xl font-bold text-white mb-2">Monkey Type Live</h1>
            <p class="text-gray-400 text-sm mb-6">Ketik secepat kilat. Gunakan Spasi/Enter.</p>
            
            <div id="finalScoreDisplay" class="hidden mb-6 bg-[#1e1d1b] p-4 rounded-lg border border-red-500/30 transform transition-all">
                <p class="text-xs text-gray-400 uppercase tracking-wider">Skor Akhir</p>
                <p class="text-4xl font-bold text-white mt-1" id="finalScoreValue">0</p>
            </div>

            <button id="startBtn" class="w-full bg-[#e2b714] hover:bg-[#c9a212] text-[#2c2b29] font-bold py-3.5 px-6 rounded-xl text-lg shadow-lg active:scale-95 transition-all flex items-center justify-center gap-2">
                <i data-lucide="play" class="fill-current"></i> <span id="btnText">Mulai</span>
            </button>
        </div>
    </div>

    <script>
        // Init Icons safely
        document.addEventListener("DOMContentLoaded", () => {
            if (window.lucide) lucide.createIcons();
        });

        // Config
        const INITIAL_TIME = 15;
        const BONUS_TIME = 5;
        
        // State
        let words = [];
        let currentWordIndex = 0;
        let score = 0;
        let highScore = localStorage.getItem('monkeyHighScore') || 0;
        let timeLeft = INITIAL_TIME;
        let timerInterval;
        let isPlaying = false;
        let wordBuffer = []; 

        // DOM
        const els = {
            container: document.getElementById('wordsContainer'),
            input: document.getElementById('wordInput'),
            timer: document.getElementById('timer'),
            score: document.getElementById('score'),
            highScore: document.getElementById('highScore'),
            loader: document.getElementById('loader'),
            overlay: document.getElementById('overlay'),
            startBtn: document.getElementById('startBtn'),
            btnText: document.getElementById('btnText'),
            finalScoreDisplay: document.getElementById('finalScoreDisplay'),
            finalScoreValue: document.getElementById('finalScoreValue'),
            bonusAnim: document.getElementById('bonusTimeAnim'),
            liveStatus: document.getElementById('liveStatus')
        };

        els.highScore.textContent = highScore;

        // --- Logic Wikipedia ---
        async function fetchWikiWords() {
            try {
                const response = await fetch('https://id.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&generator=random&grnnamespace=0&grnlimit=3&origin=*');
                const data = await response.json();
                
                if (!data.query?.pages) throw new Error('No pages');

                const rawText = Object.values(data.query.pages).map(p => p.extract).join(' ');
                
                // Cleaning Process
                const cleaned = rawText
                    .replace(/\[.*?\]/g, '') 
                    .replace(/\(.*?\)/g, '')
                    .replace(/[^\w\s-]/g, '') // Remove punctuation except hyphens
                    .replace(/\s+/g, ' ')
                    .trim();

                // Filter short words and create array
                return cleaned.split(' ').filter(w => w.length > 2);
            } catch (e) {
                // Offline fallback
                return ["Monyet", "Pisang", "Hutan", "Pohon", "Cepat", "Ketik", "Lari", "Suka", "Makan", "Buah", "Manis", "Lompat", "Tinggi", "Langit", "Biru", "Awan", "Indonesia", "Merdeka", "Belajar", "Coding"];
            }
        }

        async function replenishBuffer() {
            if (wordBuffer.length < 40) {
                const newWords = await fetchWikiWords();
                wordBuffer.push(...newWords);
                if (words.length === 0 && isPlaying) {
                    words = wordBuffer.splice(0, 30);
                    renderWords();
                }
            }
        }

        // --- Rendering & Visuals ---

        function renderWords() {
            els.container.innerHTML = '';
            words.forEach((word, index) => {
                const span = document.createElement('div'); // Use div for better spacing control
                span.textContent = word;
                span.dataset.index = index;
                span.dataset.word = word; // Store original word for easy access
                
                // Base styles
                let classes = "inline-block px-2 py-1 rounded mx-1 mb-2 transition-all duration-200 ";
                if (index === currentWordIndex) {
                    classes += "active-word-text bg-[#3d3b38] border-b-2 border-[#e2b714]";
                } else if (index < currentWordIndex) {
                    classes += "text-gray-600 opacity-50"; // Done words
                } else {
                    classes += "text-gray-500"; // Future words
                }
                
                span.className = classes;
                els.container.appendChild(span);
            });
            updateActiveWordView('');
            scrollToActiveWord();
        }

        // The "Live" Highlighting Logic
        function updateActiveWordView(currentInput) {
            const activeEl = els.container.querySelector(`div[data-index="${currentWordIndex}"]`);
            if (!activeEl) return;

            const targetWord = words[currentWordIndex];
            const input = currentInput.trim().toLowerCase(); // Case insensitive compare
            const targetLower = targetWord.toLowerCase();

            // Check correctness of current input vs target
            // We want to colorize the letters inside the active word span
            
            let html = '';
            for (let i = 0; i < targetWord.length; i++) {
                const targetChar = targetWord[i];
                const inputChar = input[i];

                if (inputChar) {
                    if (inputChar.toLowerCase() === targetChar.toLowerCase()) {
                        html += `<span class="char-correct">${targetChar}</span>`;
                    } else {
                        html += `<span class="char-wrong">${targetChar}</span>`;
                    }
                } else {
                    html += `<span class="char-default">${targetChar}</span>`;
                }
            }
            
            // If user typed more characters than the word has (overflow error)
            if (input.length > targetWord.length) {
                const extra = input.slice(targetWord.length);
                html += `<span class="text-red-500 font-bold opacity-70">${extra}</span>`;
            }

            activeEl.innerHTML = html;
        }

        function scrollToActiveWord() {
            const activeEl = els.container.querySelector(`div[data-index="${currentWordIndex}"]`);
            if (activeEl) {
                // Force scroll to make the active word appear at the TOP
                // We do this by calculating the offsetTop of the element relative to the container
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function updateTimer() {
            els.timer.textContent = timeLeft + 's';
            els.liveStatus.classList.toggle('opacity-50'); // Blinking dot
        }

        // --- Core Game Loop ---

        function gameOver() {
            isPlaying = false;
            clearInterval(timerInterval);
            els.input.disabled = true;
            els.input.blur();
            els.liveStatus.className = "w-2 h-2 rounded-full bg-red-500";
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('monkeyHighScore', highScore);
                els.highScore.textContent = highScore;
            }

            els.finalScoreValue.textContent = score;
            els.finalScoreDisplay.classList.remove('hidden');
            els.btnText.textContent = "Main Lagi";
            els.overlay.classList.remove('hidden');
        }

        function submitWord() {
            const rawInput = els.input.value;
            // Handle if user typed Space/Enter, input might have trailing space
            const inputVal = rawInput.trim().toLowerCase();
            const targetVal = words[currentWordIndex].toLowerCase();

            if (inputVal === targetVal) {
                // Correct
                score++;
                els.score.textContent = score;
                timeLeft += BONUS_TIME;
                updateTimer();
                
                // Bonus Animation
                els.bonusAnim.classList.remove('hidden', 'animate-bounce');
                void els.bonusAnim.offsetWidth; // trigger reflow
                els.bonusAnim.classList.add('hidden', 'animate-bounce'); // Simple blink logic needed
                els.bonusAnim.classList.remove('hidden');
                setTimeout(() => els.bonusAnim.classList.add('hidden'), 800);

                // Mark previous as done visually
                const oldEl = els.container.querySelector(`div[data-index="${currentWordIndex}"]`);
                if(oldEl) {
                    oldEl.className = "inline-block px-2 py-1 rounded mx-1 mb-2 text-green-600 opacity-50";
                    oldEl.innerHTML = words[currentWordIndex]; // Reset HTML structure
                }

                currentWordIndex++;
                els.input.value = '';

                // Buffer check
                if (currentWordIndex >= words.length - 5) {
                    if (wordBuffer.length > 0) {
                        words = [...words, ...wordBuffer.splice(0, 15)];
                        // We append new words to DOM without destroying old ones to keep scroll smooth?
                        // Or just re-render next batch? Let's re-render to clean up DOM.
                        // But to keep index sync, we need to be careful.
                        // Simpler: Just append to words array and append elements to DOM
                        const fragment = document.createDocumentFragment();
                        wordBuffer.splice(0, 15).forEach((w, i) => {
                             // Logic to append new spans... skipping complex partial render for safety, 
                             // just letting the existing array grow is fine for memory in short sessions.
                        });
                        // Actually, easiest way is full re-render but preserve scroll?
                        // Let's just do full re-render but keep index.
                        renderWords();
                    } else {
                        replenishBuffer();
                    }
                } else {
                    // Update next active word style
                    const newEl = els.container.querySelector(`div[data-index="${currentWordIndex}"]`);
                    if(newEl) {
                        newEl.className = "inline-block px-2 py-1 rounded mx-1 mb-2 active-word-text bg-[#3d3b38] border-b-2 border-[#e2b714]";
                        updateActiveWordView(''); // Init highlights
                        scrollToActiveWord();
                    }
                }
            } else {
                // Wrong submission
                els.input.classList.add('border-red-500');
                setTimeout(() => els.input.classList.remove('border-red-500'), 200);
            }
        }

        async function startGame() {
            score = 0;
            els.score.textContent = '0';
            timeLeft = INITIAL_TIME;
            updateTimer();
            currentWordIndex = 0;
            words = [];
            wordBuffer = [];
            
            els.overlay.classList.add('hidden');
            els.loader.classList.remove('hidden');
            els.input.value = '';
            els.liveStatus.className = "w-2 h-2 rounded-full bg-green-500 animate-pulse";
            
            await replenishBuffer();
            words = wordBuffer.splice(0, 30);
            
            els.loader.classList.add('hidden');
            renderWords();
            els.input.disabled = false;
            els.input.focus();
            isPlaying = true;

            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimer();
                if (timeLeft <= 0) gameOver();
            }, 1000);

            replenishBuffer();
        }

        // --- Event Listeners ---

        els.startBtn.addEventListener('click', startGame);

        els.input.addEventListener('input', (e) => {
            if (!isPlaying) return;

            const val = e.target.value;
            
            // Check for Space (standard behavior)
            if (val.endsWith(' ')) {
                submitWord();
                return;
            }

            // Live Highlighting
            updateActiveWordView(val);
        });

        // Handle Enter Key as Submit
        els.input.addEventListener('keydown', (e) => {
            if (!isPlaying) return;
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission logic if any
                submitWord();
            }
        });

        // Prevent double tap zoom
        document.addEventListener('dblclick', (e) => e.preventDefault(), { passive: false });

    </script>
</body>
</html>
